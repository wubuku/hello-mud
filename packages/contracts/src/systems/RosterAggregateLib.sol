// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

/* Autogenerated file. Do not edit manually. */

import { Roster, RosterData } from "../codegen/index.sol";
import { RosterSetSail } from "./RosterEvents.sol";
import { RosterSetSailLogic } from "./RosterSetSailLogic.sol";
import { SystemRegistry } from "@latticexyz/world/src/codegen/tables/SystemRegistry.sol";
import { NamespaceOwner } from "@latticexyz/world/src/codegen/tables/NamespaceOwner.sol";
import { ResourceId, WorldResourceIdInstance } from "@latticexyz/world/src/WorldResourceId.sol";
import { WorldContextConsumerLib } from "@latticexyz/world/src/WorldContext.sol";

library RosterAggregateLib {
  using WorldResourceIdInstance for ResourceId;

  event RosterSetSailEvent(uint256 indexed playerId, uint32 indexed sequenceNumber, uint32 targetCoordinatesX, uint32 targetCoordinatesY, uint64 sailDuration, uint64 setSailAt, uint32 updatedCoordinatesX, uint32 updatedCoordinatesY, uint64 energyCost);

  function _requireNamespaceOwner() internal view {
    ResourceId _thisSystemId = SystemRegistry.get(address(this));
    address _thisNamespaceOwner = NamespaceOwner.get(_thisSystemId.getNamespaceId());
    require(_thisNamespaceOwner == WorldContextConsumerLib._msgSender(), "Require namespace owner");
  }

  function setSail(uint256 playerId, uint32 sequenceNumber, uint32 targetCoordinatesX, uint32 targetCoordinatesY, uint64 sailDuration, uint32 updatedCoordinatesX, uint32 updatedCoordinatesY) internal {
    RosterData memory rosterData = Roster.get(playerId, sequenceNumber);
    require(
      !(rosterData.status == uint8(0) && rosterData.speed == uint32(0) && rosterData.baseExperience == uint32(0) && rosterData.environmentOwned == false && rosterData.updatedCoordinatesX == uint32(0) && rosterData.updatedCoordinatesY == uint32(0) && rosterData.coordinatesUpdatedAt == uint64(0) && rosterData.targetCoordinatesX == uint32(0) && rosterData.targetCoordinatesY == uint32(0) && rosterData.originCoordinatesX == uint32(0) && rosterData.originCoordinatesY == uint32(0) && rosterData.sailDuration == uint64(0) && rosterData.setSailAt == uint64(0) && rosterData.shipBattleId == uint256(0) && rosterData.shipIds.length == 0),
      "Roster does not exist"
    );
    RosterSetSail memory rosterSetSail = RosterSetSailLogic.verify(playerId, sequenceNumber, targetCoordinatesX, targetCoordinatesY, sailDuration, updatedCoordinatesX, updatedCoordinatesY, rosterData);
    rosterSetSail.playerId = playerId;
    rosterSetSail.sequenceNumber = sequenceNumber;
    emit RosterSetSailEvent(rosterSetSail.playerId, rosterSetSail.sequenceNumber, rosterSetSail.targetCoordinatesX, rosterSetSail.targetCoordinatesY, rosterSetSail.sailDuration, rosterSetSail.setSailAt, rosterSetSail.updatedCoordinatesX, rosterSetSail.updatedCoordinatesY, rosterSetSail.energyCost);
    RosterData memory updatedRosterData = RosterSetSailLogic.mutate(rosterSetSail, rosterData);
    Roster.set(playerId, sequenceNumber, updatedRosterData);
  }

}
