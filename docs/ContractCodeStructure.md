# Contract Code Structure And DDDML Driven Development


## Prerequisites for Readers

* Basic understanding of the MUD framework and the structure of MUD-based Dapps
* General familiarity with DDD (Domain-Driven Design) and DDDML concepts

DDDML is a domain-specific language (DSL) we created based on the philosophy of DDD.
For an introductory reference on using DDDML and related tools for MUD application development, see: https://hackmd.io/GjSU_oWvTlCtMBtIA28SiA


## The Process of Generating Contract Code

> Note: *dddappp* is the low-code tool we created. 
> It supports the development of Move Dapps and EVM/MUD Dapps using DDDML models. 
> (Future versions will support more Web3 infrastructures. In fact, it also supports the development of "traditional" Web2 applications now.)


```ascii
                   DDDML Models (*.yaml)
                          │
                          │ dddappp tool (MUD version)
                          ▼
     ┌─────────────────────────────────────────┐
     │                                         │
     ▼                                         ▼
MUD Data Model                          MUD Systems
(mud.config.ts)                    (*System.sol & *Logic.sol)
     │                                         │
     │ mud tablegen                            │ mud worldgen
     ▼                                         ▼
Tables (DAL)                          Interfaces
(codegen/tables/*.sol)               (codegen/world/*.sol)
     │                                         │
     └─────────────────┐     ┌─────────────────┘
                       │     │
                       ▼     ▼
                   Final Contract
                      Code
```


This diagram illustrates the transformation process from DDDML models to final contract code:

1. DDDML models (`*.yaml` files) represent the highest level of abstraction, describing the domain model
2. The dddappp tool (MUD version) converts DDDML models into:
   - MUD data model (in `mud.config.ts`)
   - MUD Systems (Solidity contracts) and the "business logic" scaffolding code for the methods defined in the models
3. The MUD toolchain further processes:
   - `tablegen` generates DAL code from the MUD data model
   - `worldgen` extracts interface definitions from MUD Systems
4. Finally, all these components combine into the complete contract code (the developer needs to fill in the implementation of "business logic")


## Contract Project Structure


It's easy to identify which contract code is generated by the tool (the contracts are in the `packages/contracts` directory):

- There is a comment like `/* Autogenerated file. Do not edit manually. */` at the start of the generated code file.
- It's easy to identify the generated code by the file name: files ending with `Logic.sol` or `ServiceSystem.sol` need to be implemented by developers. (However, these files are also scaffolded by the tool, containing the function signatures, and developers only need to fill in the function bodies.)
- The files in the `src/utils` directory are developer-written utility libraries.

Using the tree command to view the project structure:

```
cd packages/contracts
tree .
```

And we add comments in the output to explain the purpose of each directory and file, as follows:


```txt
.
├── ...
├── script // Deployment and other DevOps scripts
│   ├── ...
│   ├── PostDeploy.s.sol
│   └── ...
├── src
│   ├── codegen // The files in this directory are generated by MUD's tool
│   │   ├── index.sol
│   │   ├── tables // MUD's tool generated DAL (Data Access Layer) code
│   │   │   ├── EnergyDrop.sol
│   │   │   ├── ...
│   │   │   └── XpTableLevelCount.sol
│   │   └── world // The files in this directory are generated by MUD's tool as interfaces
│   │       ├── IAggregatorServiceSystem.sol
│   │       ├── ...
│   │       └── IWorld.sol
│   ├── systems // The files with the `Logic.sol` and `ServiceSystem.sol` suffixes contain manually written code
│   │   ├── EnergyDropRequestLogic.sol
│   │   ├── ExperienceTableAddLevelLogic.sol
│   │   ├── IslandClaimWhitelistAddLogic.sol
│   │   ├── ...
│   │   ├── ItemProductionCreateLogic.sol
│   │   ├── ItemUpdateLogic.sol
│   │   ├── MapAddIslandLogic.sol
│   │   ├── ...
│   │   ├── AggregatorServiceSystem.sol
│   │   ├── ShipBattleServiceSystem.sol
│   │   ├── ...
│   ├── tokens // ENERGY ERC-20 contract, the contract address of the ENERGY token is configurable
│   │   └── Energy.sol
│   └── utils // Utility functions
│       ├── DirectRouteUtil.sol
│       ├── ExperienceTableUtil.sol
│       ├── FightToDeath.sol
│       ├── ItemIds.sol
│       ├── LootUtil.sol
│       ├── MapUtil.sol
│       ├── PlayerInventoryUpdateUtil.sol
│       ├── PlayerUtil.sol
│       ├── RosterDataInstance.sol
│       ├── RosterSailUtil.sol
│       ├── RosterUtil.sol
│       ├── RouteUtil.sol
│       ├── ShipBattleUtil.sol
│       ├── ShipIdUtil.sol
│       ├── ShipInventoryUpdateUtil.sol
│       ├── ShipUtil.sol
│       ├── SkillProcessUtil.sol
│       ├── SortedVectorUtil.sol
│       ├── SpeedUtil.sol
│       └── TsRandomUtil.sol
├── test // Unit tests
│   ├── ShipIdUtilTest.t.sol
│   └── ...

```

## Mapping DDDML Models to Contract Code


> Note: *Aggregate*, *Aggregate Root*, *Entity* are concepts in DDD. You can spend a few minutes to google and understand the concepts of DDD, this will help you understand this article.
> If you want to scroll down first, just remember: *Aggregate Root* is a kind of *Entity*.
> *Entity* is a concept that most people with technical backgrounds are already familiar with, usually it can be understood as: an object with a unique identifier.


### Example Entity Model and Generated Code

#### Example: `Item`

This is the DDDML model file for the `Item` aggregate root:

```yaml
aggregates:
  Item:
    metadata:
      Preprocessors: [ "CRUD_IT" ]
      #CRUD_IT_NO_UPDATE: true
      CRUD_IT_NO_DELETE: true
    id:
      name: ItemId
      type: u32
    properties:
      RequiredForCompletion:
        type: bool
      SellsFor:
        type: u32
      Name:
        type: string
        length: 100
    methods:
      Create:
        requiredPermission: __NamespaceOwner__ # "__Publisher__"
      Update:
        requiredPermission: __NamespaceOwner__ # "__Publisher__"
```


If CRUD (Create, Read, Update, Delete) is all the "business logic" you need, then you don't even need to write any code. Just like the `Item` entity above.
We use the `CRUD_IT` preprocessor to generate code for the `Create` and `Update` methods, while disabling the generation of the `Delete` method.

- The DAL code generated by MUD tools is in: `src/codegen/tables/Item.sol`
- The System contract file for this model is in: `src/systems/ItemSystem.sol`. Each MUD System is a stateless Solidity contract.
- The implementation of the "business logic" for the `Create` and `Update` methods is in:
  - `src/systems/ItemCreateLogic.sol`
  - `src/systems/ItemUpdateLogic.sol`
  - If the methods defined in the model are not "CRUD", developers need to fill in the implementation of "business logic" in `{EntityName}{MethodName}Logic.sol`, but these two files don't need that here.


#### Call Relationships Between Code

Taking the `Create` method of the `Item` entity as an example. Here's a code snippet from the generated `ItemSystem.sol` contract:


```solidity
// ...
contract ItemSystem is System, IAppSystemErrors {
   // ...
  function itemCreate(uint32 itemId, bool requiredForCompletion, uint32 sellsFor, string memory name) public {
    _requireNamespaceOwner(); // Check if the caller is the namespace owner
    ItemData memory itemData = Item.get(itemId); // Use MUD-generated DAL library to read data
    if (!(itemData.requiredForCompletion == false && itemData.sellsFor == uint32(0) && bytes(itemData.name).length == 0)) {
      revert ItemAlreadyExists(itemId);
    }
    ItemCreated memory itemCreated = ItemCreateLogic.verify(itemId, requiredForCompletion, sellsFor, name); 
    // Above calls `ItemCreateLogic.verify` function to verify the input; this function returns an "event" object
    itemCreated.itemId = itemId;
    emit ItemCreatedEvent(itemCreated.itemId, itemCreated.requiredForCompletion, itemCreated.sellsFor, itemCreated.name);
    ItemData memory newItemData = ItemCreateLogic.mutate(itemCreated); 
    // Calls ItemCreateLogic.mutate function to modify the entity's "state", 
    // since this is a create operation, no "old state" is passed in
    Item.set(itemId, newItemData); // Calls MUD's generated DAL library to save the modified entity state

    // You can compare the call to `ItemUpdateLogic.mutate` function in the `itemUpdate` function:
    //     ItemData memory updatedItemData = ItemUpdateLogic.mutate(itemUpdated, itemData);
    //     Item.set(itemId, updatedItemData);
    // to understand the difference between "create" and "update" operations.
  }
  // ...
}
```


### Other Object Models and Generated Code


#### Value Objects

Value objects are simple data structures. No corresponding MUD tables will be generated for them.

##### Example: `ItemIdQuantityPair`

Model file:

```yaml
valueObjects:
  ItemIdQuantityPair:
    properties:
      ItemId:
        type: u32 # ID of the item
      Quantity:
        type: u32 # Quantity of the item
```

In the Infinite Seas game model, many places (object properties, method parameters) need to use combinations like "item ID and quantity".
We can directly use the `ItemIdQuantityPair` type in these places, which makes the model description more concise and clear.

The corresponding Solidity code is in `src/systems/ItemIdQuantityPair.sol`.

```solidity
// ...
struct ItemIdQuantityPair {
  uint32 itemId;
  uint32 quantity;
}
```

##### Example: `SkillProcessId`

Model file:

```yaml
valueObjects:
  SkillProcessId:
    properties:
      SkillType:
        type: SkillType
      PlayerId:
        type: u256
      SequenceNumber:
        type: u8
```

The corresponding Solidity code is in `src/Systems/SkillProcessId.sol`.

#### Services

Generally speaking, services should not contain overly complex business logic. They should implement functionality by combining calls to "entity methods" using some "glue" code.

##### Example: `AggregatorService`

```yaml
services:
  AggregatorService:
    metadata:
      GlobalFunctionNamePrefix: "UniApi" # Unified API
    methods:
      StartCreation:
        parameters:
          SkillType:
            type: u8
          PlayerId:
            type: u256
          SkillProcessSequenceNumber:
            type: u8
          ItemId:
            type: u32
          BatchSize:
            type: u32
      # ...
```

Our tool generates corresponding MUD System contracts for Services.
One of the intentions of defining this Service is to centralize functions that consume ENERGY tokens here, so users only need to approve this contract to use ENERGY tokens (rather than approving multiple contracts).

The corresponding Solidity code is in `src/Systems/AggregatorService.sol`. The function bodies in this file need to be filled in by developers.

```solidity
contract AggregatorServiceSystem is System {
  // ...
  function uniApiStartCreation(
    uint8 skillType,
    uint256 playerId,
    uint8 skillProcessSequenceNumber,
    uint32 itemId,
    uint32 batchSize
  ) public {
    // ...
    SkillProcessDelegatecallLib.startCreation(skillType, playerId, skillProcessSequenceNumber, itemId, batchSize);
  }
}
```

### Key Declarations in Models and Their Impact on Generated Code


#### Dividing Code into Systems

By default, the dddappp tool generates corresponding System contracts for each entity (aggregate root).

- Entity methods are by default placed in contracts named `{EntityName}System.sol`.
- Methods with the `IsOnlyOpenToFriends` property set to `true` are by default placed in contracts named `{EntityName}FriendSystem.sol`.

We can also control which System contract the generated code for a method is placed in by using the `MudSystemName` property in the model.

Here's a code snippet from the DDDML model file of the `Roster` aggregate root:

```yaml
aggregates:
  Roster:
    # ...
    methods:
      Create:
        metadata:
          IsOnlyOpenToFriends: true
          # This method will be generated in the `RosterFriendSystem` contract by default
          isCreationCommand: true
          parameters:
            # ...

      SetSail:
        metadata:
          IsOnlyOpenToFriends: true
          MudSystemName: RosterSailingSystem
          DisableFlatteningForParameters: ["UpdateLocationParams"]
        parameters:
          # ...

      CleanUpBattleDestroyedShips:
        metadata:
          IsOnlyOpenToFriends: true
          MudSystemName: RosterCleaningSystem
        parameters:
          # ...


      TransferShip:
        # IsOnlyOpenToFriends defaults to false.
        # This method will be generated in the `RosterSystem` contract by default
        parameters:
          ShipId:
            type: u256
          # ...
        event:
          name: RosterShipTransferred
          # ...
```

It's important to note that methods placed in the same system must have the same value for their `IsOnlyOpenToFriends` property.

When a system (all methods within it) has the `IsOnlyOpenToFriends` property set to `true`, its `openAccess` property in the MUD configuration file `mud.config.ts` will be set to `false`. This means that functions in this system cannot be called externally by default.
(As mentioned earlier, this MUD configuration file is generated by the dddappp tool based on the model files.)

```typescript
export default defineWorld({
  namespace: "app",
  // ...
  systems: {
    // ...
    RosterFriendSystem: {
      openAccess: false,
    },
    RosterSailingSystem: {
      openAccess: false,
    },
    RosterCleaningSystem: {
      openAccess: false,
    },
    // ...
  },
  // ...
});
```

#### Contract Size Limit

Placing "common" code in library code in the `utils` directory can achieve code reuse, but it doesn't effectively reduce the size of the compiled contracts.

Ethereum contracts are limited in size, and while you can use a public library to work around that limit,
using public libraries means these "contracts" are outside of MUD framework's management and cannot utilize the conveniences provided by the MUD toolchain, such as those during contract compilation and deployment.
Moreover, when writing business logic in them, the code in public libraries cannot directly use MUD framework functions like `_msgSender()` and `_msgValue()`. While we can work around this by passing corresponding values as function parameters, this makes the code inconsistent in style with business logic implementation in other Systems and less concise and intuitive.

> Note: A MUD System is essentially a stateless contract, similar to a "public library" in this aspect.
> Calls to MUD System contracts are generally proxied through the World contract. The state of MUD applications is managed under the MUD framework.

Our approach, as shown above, is to declare methods that need to be "extracted" into "public libraries" with `IsOnlyOpenToFriends: true` in the model. This causes the `openAccess` property of the MUD System containing these methods (functions) to be set to `false`. Other contracts can then call these contracts/functions using delegatecall.

To facilitate other contracts calling these "public library-like" MUD System contracts, our DDDML tool generates corresponding "wrapper" libraries (`{EntityName}DelegatecallLib.sol`).

For example, here's a code snippet from the `RosterDelegatecallLib` library:

```solidity
library RosterDelegatecallLib {
  // ...
  function setSail(uint256 playerId, uint32 sequenceNumber, uint32 targetCoordinatesX, uint32 targetCoordinatesY, uint64 sailDuration, UpdateLocationParams memory updateLocationParams, Coordinates[] memory intermediatePoints) internal {
    ResourceId rosterSailingSystemId = WorldResourceIdLib.encode({
      typeId: RESOURCE_SYSTEM,
      namespace: "app",
      name: "RosterSailingSys" // NOTE: Only the first 16 characters are used. Original: "RosterSailingSystem"
    });

    (address rosterSailingSystemAddress, ) = Systems.get(rosterSailingSystemId);
    (bool success, bytes memory returnData) = WorldContextProviderLib.delegatecallWithContext(
      WorldContextConsumerLib._msgSender(),
      0,
      rosterSailingSystemAddress,
      abi.encodeWithSignature(
        "rosterSetSail(uint256,uint32,uint32,uint32,uint64,((uint32,uint32),uint16,uint64),(uint32,uint32)[])",
        playerId, sequenceNumber, targetCoordinatesX, targetCoordinatesY, sailDuration, updateLocationParams, intermediatePoints
      )
    );
    if (!success) revertWithBytes(returnData);

  }
  // ...
}
```

In the example code above, we use the `WorldContextProviderLib.delegatecallWithContext` library function provided by the MUD framework.
It extends Solidity's native `delegatecall` function by adding the ability to pass MUD framework context variables.
This allows the called system contracts to use MUD framework functions like `_msgSender()` and `_msgValue()`.





