# Contract Code Structure And DDDML Driven Development


## Prerequisites for Readers

* Basic understanding of the MUD framework and the structure of MUD-based Dapps
* General familiarity with DDDML concepts

For an introductory reference on using DDDML and related tools for MUD application development, see: https://hackmd.io/GjSU_oWvTlCtMBtIA28SiA


## The Process of Generating Contract Code

> Note: *dddappp* is the low-code tool we created. 
> It supports the development of Move Dapps and EVM/MUD Dapps using DDDML models. 
> (In fact, it also supports the development of "traditional" applications.)


```ascii
                   DDDML Models (*.yaml)
                          │
                          │ dddappp tool (MUD version)
                          ▼
     ┌─────────────────────────────────────────┐
     │                                         │
     ▼                                         ▼
MUD Data Model                          MUD Systems
(mud.config.ts)                    (*System.sol / *Logic.sol)
     │                                         │
     │ mud tablegen                            │ mud worldgen
     ▼                                         ▼
Tables (DAL)                          Interfaces
(codegen/tables/*.sol)               (codegen/world/*.sol)
     │                                         │
     └─────────────────┐     ┌─────────────────┘
                       │     │
                       ▼     ▼
                   Final Contract
                      Code
```


This diagram illustrates the transformation process from DDDML models to final contract code:

1. DDDML models (*.yaml files) represent the highest level of abstraction, describing the domain model
2. The dddappp tool (MUD version) converts DDDML models into:
   - MUD data model (in `mud.config.ts`)
   - MUD Systems (Solidity contracts) and the "business logic" scaffolding code for the methods defined in the models
3. The MUD toolchain further processes:
   - `tablegen` generates DAL code from the MUD data model
   - `worldgen` extracts interface definitions from MUD Systems
4. Finally, all these components combine into the complete contract code (the developer needs to fill in the implementation of "business logic")


It's easy to identify which contract code is generated by the tool (the contracts are in the `packages/contracts` directory):

- There is a comment like `/* Autogenerated file. Do not edit manually. */` at the top of the generated code file.
- It's easy to identify the generated code by the file name: files ending with `Logic.sol` or `ServiceSystem.sol` need to be implemented by developers. (However, these files are also scaffolded by the tool, containing the function signatures, and developers need to fill in the function bodies.)
- The files in the `src/utils` directory are developer-written utility libraries.


## Contract Project Structure

Using the tree command to view the project structure:

```
cd packages/contracts
tree .
```

And we add comments in the output to explain the purpose of each directory and file, as follows:


```txt
.
├── ...
├── script // Deployment and other DevOps scripts
│   ├── ...
│   ├── PostDeploy.s.sol
│   └── ...
├── src
│   ├── codegen // The files in this directory are generated by MUD's tool
│   │   ├── index.sol
│   │   ├── tables // MUD's tool generated DAL (Data Access Layer) code
│   │   │   ├── EnergyDrop.sol
│   │   │   ├── ...
│   │   │   └── XpTableLevelCount.sol
│   │   └── world // The files in this directory are generated by MUD's tool as interfaces
│   │       ├── IAggregatorServiceSystem.sol
│   │       ├── ...
│   │       └── IWorld.sol
│   ├── systems // The files with the `Logic.sol` and `ServiceSystem.sol` suffixes contain manually written code
│   │   ├── EnergyDropRequestLogic.sol
│   │   ├── ExperienceTableAddLevelLogic.sol
│   │   ├── IslandClaimWhitelistAddLogic.sol
│   │   ├── ...
│   │   ├── ItemProductionCreateLogic.sol
│   │   ├── ItemUpdateLogic.sol
│   │   ├── MapAddIslandLogic.sol
│   │   ├── ...
│   │   ├── AggregatorServiceSystem.sol
│   │   ├── ShipBattleServiceSystem.sol
│   │   ├── ...
│   ├── tokens // ENERGY ERC-20 contract, the contract address of the ENERGY token is configurable
│   │   └── Energy.sol
│   └── utils // Utility functions
│       ├── DirectRouteUtil.sol
│       ├── ExperienceTableUtil.sol
│       ├── FightToDeath.sol
│       ├── ItemIds.sol
│       ├── LootUtil.sol
│       ├── MapUtil.sol
│       ├── PlayerInventoryUpdateUtil.sol
│       ├── PlayerUtil.sol
│       ├── RosterDataInstance.sol
│       ├── RosterSailUtil.sol
│       ├── RosterUtil.sol
│       ├── RouteUtil.sol
│       ├── ShipBattleUtil.sol
│       ├── ShipIdUtil.sol
│       ├── ShipInventoryUpdateUtil.sol
│       ├── ShipUtil.sol
│       ├── SkillProcessUtil.sol
│       ├── SortedVectorUtil.sol
│       ├── SpeedUtil.sol
│       └── TsRandomUtil.sol
├── test // Unit tests
│   ├── ShipIdUtilTest.t.sol
│   └── ...

```

## Mapping DDDML Models to Contract Code

### Example Entity Model and Generated Code

#### Example: `Item`

Model file:

```yaml
aggregates:
  Item:
    metadata:
      Preprocessors: [ "CRUD_IT" ]
      #CRUD_IT_NO_UPDATE: true
      CRUD_IT_NO_DELETE: true
    id:
      name: ItemId
      type: u32
    properties:
      RequiredForCompletion:
        type: bool
      SellsFor:
        type: u32
      Name:
        type: string
        length: 100
    methods:
      Create:
        requiredPermission: __NamespaceOwner__ # "__Publisher__"
      Update:
        requiredPermission: __NamespaceOwner__ # "__Publisher__"
```


If CRUD (Create, Read, Update, Delete) is all the "business logic" you need, then you don't even need to write any code. Just like the `Item` entity above.
We use the `CRUD_IT` preprocessor to generate code for the `Create` and `Update` methods, while disabling the generation of the `Delete` method.

- The DAL code generated by MUD tools is in: `src/codegen/tables/Item.sol`
- The System contract file for this model is in: `src/systems/ItemSystem.sol`. Each MUD System is a stateless Solidity contract.
- The implementation of the "business logic" for the `Create` and `Update` methods is in:
  - `src/systems/ItemCreateLogic.sol`
  - `src/systems/ItemUpdateLogic.sol`
  - If the methods defined in the model are not "CRUD", developers need to fill in the implementation of "business logic" in `{EntityName}{MethodName}Logic.sol`, but these two files don't need that here.


#### Call Relationships Between Code

Taking the `Create` method of the `Item` entity as an example. Here's a code snippet from the generated `ItemSystem.sol` contract:


```solidity
// ...
contract ItemSystem is System, IAppSystemErrors {
   // ...
  function itemCreate(uint32 itemId, bool requiredForCompletion, uint32 sellsFor, string memory name) public {
    _requireNamespaceOwner(); // Check if the caller is the namespace owner
    ItemData memory itemData = Item.get(itemId); // Use MUD-generated DAL library to read data
    if (!(itemData.requiredForCompletion == false && itemData.sellsFor == uint32(0) && bytes(itemData.name).length == 0)) {
      revert ItemAlreadyExists(itemId);
    }
    ItemCreated memory itemCreated = ItemCreateLogic.verify(itemId, requiredForCompletion, sellsFor, name); 
    // Above calls `ItemCreateLogic.verify` function to verify the input; this function returns an "event" object
    itemCreated.itemId = itemId;
    emit ItemCreatedEvent(itemCreated.itemId, itemCreated.requiredForCompletion, itemCreated.sellsFor, itemCreated.name);
    ItemData memory newItemData = ItemCreateLogic.mutate(itemCreated); 
    // Calls ItemCreateLogic.mutate function to modify the entity's "state", 
    // since this is a create operation, no "old state" is passed in
    Item.set(itemId, newItemData); // Calls MUD's generated DAL library to save the modified entity state

    // You can compare the call to `ItemUpdateLogic.mutate` function in the `itemUpdate` function:
    //     ItemData memory updatedItemData = ItemUpdateLogic.mutate(itemUpdated, itemData);
    //     Item.set(itemId, updatedItemData);
    // to understand the difference between "create" and "update" operations.
  }
  // ...
}
```


### Other Object Models and Generated Code


#### Value Objects

Value objects are simple data structures. No corresponding MUD tables will be generated for them.

##### Example: `ItemIdQuantityPair`

Model file:

```yaml
valueObjects:
  ItemIdQuantityPair:
    properties:
      ItemId:
        type: u32 # ID of the item
      Quantity:
        type: u32 # Quantity of the item
```

In the Infinite Seas game model, many places (object properties, method parameters) need to use combinations like "item ID and quantity".
We can directly use the `ItemIdQuantityPair` type in these places, which makes the model description more concise and clear.

The corresponding Solidity code is in `src/Systems/ItemIdQuantityPair.sol`.

```solidity
// ...
struct ItemIdQuantityPair {
  uint32 itemId;
  uint32 quantity;
}
```

##### Example: `SkillProcessId`

Model file:

```yaml
valueObjects:
  SkillProcessId:
    properties:
      SkillType:
        type: SkillType
      PlayerId:
        type: u256
      SequenceNumber:
        type: u8
```

The corresponding Solidity code is in `src/Systems/SkillProcessId.sol`.

#### Services

Generally speaking, services should not contain overly complex business logic. They should implement functionality by combining calls to "entity methods" using some "glue" code.

##### Example: `AggregatorService`

```yaml
services:
  AggregatorService:
    metadata:
      GlobalFunctionNamePrefix: "UniApi" # Unified API
    methods:
      StartCreation:
        parameters:
          SkillType:
            type: u8
          PlayerId:
            type: u256
          SkillProcessSequenceNumber:
            type: u8
          ItemId:
            type: u32
          BatchSize:
            type: u32
      # ...
```

Our tool generates corresponding MUD System contracts for Services.
One of the intentions of defining this Service is to centralize functions that consume ENERGY tokens here, so users only need to approve this contract to use ENERGY tokens (rather than approving multiple contracts).

The corresponding Solidity code is in `src/Systems/AggregatorService.sol`. The function bodies in this file need to be filled in by developers.

```solidity
contract AggregatorServiceSystem is System {
  // ...
  function uniApiStartCreation(
    uint8 skillType,
    uint256 playerId,
    uint8 skillProcessSequenceNumber,
    uint32 itemId,
    uint32 batchSize
  ) public {
    // ...
    SkillProcessDelegatecallLib.startCreation(skillType, playerId, skillProcessSequenceNumber, itemId, batchSize);
  }
}
```

### Key Declarations in Models and Their Impact on Generated Code


