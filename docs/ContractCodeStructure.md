# Contract Code Structure And DDDML Driven Development


## Prerequisites for Readers

* Basic understanding of the MUD framework and the structure of MUD-based Dapps
* General familiarity with DDDML concepts

For an introductory reference on using DDDML and related tools for MUD application development, see: https://hackmd.io/GjSU_oWvTlCtMBtIA28SiA


## The Process of Generating Contract Code

> Note: *dddappp* is the low-code tool we created. 
> It supports the development of Move Dapps and EVM/MUD Dapps using DDDML models. 
> (In fact, it also supports the development of "traditional" applications.)


```ascii
                   DDDML Models (*.yaml)
                          │
                          │ dddappp tool (MUD version)
                          ▼
     ┌─────────────────────────────────────────┐
     │                                         │
     ▼                                         ▼
MUD Data Model                          MUD Systems
(mud.config.ts)                    (*System.sol / *Logic.sol)
     │                                         │
     │ mud tablegen                            │ mud worldgen
     ▼                                         ▼
Tables (DAL)                          Interfaces
(codegen/tables/*.sol)               (codegen/world/*.sol)
     │                                         │
     └─────────────────┐     ┌─────────────────┘
                       │     │
                       ▼     ▼
                   Final Contract
                      Code
```


This diagram illustrates the transformation process from DDDML models to final contract code:

1. DDDML models (*.yaml files) represent the highest level of abstraction, describing the domain model
2. The dddappp tool (MUD version) converts DDDML models into:
   - MUD data model (in `mud.config.ts`)
   - MUD Systems (Solidity contracts) and the "business logic" scaffolding code for the methods defined in the models
3. The MUD toolchain further processes:
   - `tablegen` generates DAL code from the MUD data model
   - `worldgen` extracts interface definitions from MUD Systems
4. Finally, all these components combine into the complete contract code (the developer needs to fill in the implementation of "business logic")


It's easy to identify which contract code is generated by the tool (the contracts are in the `packages/contracts` directory):

- There is a comment like `/* Autogenerated file. Do not edit manually. */` at the top of the generated code file.
- It's easy to identify the generated code by the file name: files ending with `Logic.sol` or `ServiceSystem.sol` need to be implemented by developers. (However, these files are also scaffolded by the tool, containing the function signatures, and developers need to fill in the function bodies.)
- The files in the `src/utils` directory are developer-written utility libraries.


## Contract Project Structure

Using the tree command to view the project structure:

```
cd packages/contracts
tree .
```

And we add comments in the output to explain the purpose of each directory and file, as follows:


```txt
.
├── ...
├── script // Deployment and other DevOps scripts
│   ├── ...
│   ├── PostDeploy.s.sol
│   └── ...
├── src
│   ├── codegen // The files in this directory are generated by MUD's tool
│   │   ├── index.sol
│   │   ├── tables // MUD's tool generated DAL (Data Access Layer) code
│   │   │   ├── EnergyDrop.sol
│   │   │   ├── ...
│   │   │   └── XpTableLevelCount.sol
│   │   └── world // The files in this directory are generated by MUD's tool as interfaces
│   │       ├── IAggregatorServiceSystem.sol
│   │       ├── ...
│   │       └── IWorld.sol
│   ├── systems // The files with the `Logic.sol` and `ServiceSystem.sol` suffixes contain manually written code
│   │   ├── EnergyDropRequestLogic.sol
│   │   ├── ExperienceTableAddLevelLogic.sol
│   │   ├── IslandClaimWhitelistAddLogic.sol
│   │   ├── ...
│   │   ├── ItemProductionCreateLogic.sol
│   │   ├── ItemUpdateLogic.sol
│   │   ├── MapAddIslandLogic.sol
│   │   ├── ...
│   │   ├── AggregatorServiceSystem.sol
│   │   ├── ShipBattleServiceSystem.sol
│   │   ├── ...
│   ├── tokens // ENERGY ERC-20 contract, the contract address of the ENERGY token is configurable
│   │   └── Energy.sol
│   └── utils // Utility functions
│       ├── DirectRouteUtil.sol
│       ├── ExperienceTableUtil.sol
│       ├── FightToDeath.sol
│       ├── ItemIds.sol
│       ├── LootUtil.sol
│       ├── MapUtil.sol
│       ├── PlayerInventoryUpdateUtil.sol
│       ├── PlayerUtil.sol
│       ├── RosterDataInstance.sol
│       ├── RosterSailUtil.sol
│       ├── RosterUtil.sol
│       ├── RouteUtil.sol
│       ├── ShipBattleUtil.sol
│       ├── ShipIdUtil.sol
│       ├── ShipInventoryUpdateUtil.sol
│       ├── ShipUtil.sol
│       ├── SkillProcessUtil.sol
│       ├── SortedVectorUtil.sol
│       ├── SpeedUtil.sol
│       └── TsRandomUtil.sol
├── test // Unit tests
│   ├── ShipIdUtilTest.t.sol
│   └── ...

```

## Mapping DDDML Models to Contract Code

### Example Entity Model and Generated Code

#### Example: `Item`

Model file:

```yaml
aggregates:
  Item:
    metadata:
      Preprocessors: [ "CRUD_IT" ]
      #CRUD_IT_NO_UPDATE: true
      CRUD_IT_NO_DELETE: true
    id:
      name: ItemId
      type: u32
    properties:
      RequiredForCompletion:
        type: bool
      SellsFor:
        type: u32
      Name:
        type: string
        length: 100
    methods:
      Create:
        requiredPermission: __NamespaceOwner__ # "__Publisher__"
      Update:
        requiredPermission: __NamespaceOwner__ # "__Publisher__"
```


If CRUD (Create, Read, Update, Delete) is all the "business logic" you need, then you don't even need to write any code. Just like the `Item` entity above.
We use the `CRUD_IT` preprocessor to generate code for the `Create` and `Update` methods, while disabling the generation of the `Delete` method.

- The DAL code generated by MUD tools is in: `src/codegen/tables/Item.sol`
- The System contract file for this model is in: `src/systems/ItemSystem.sol`. Each MUD System is a stateless Solidity contract.
- The implementation of the "business logic" for the `Create` and `Update` methods is in:
  - `src/systems/ItemCreateLogic.sol`
  - `src/systems/ItemUpdateLogic.sol`
  - If the methods defined in the model are not "CRUD", developers need to fill in the implementation of "business logic" in `{EntityName}{MethodName}Logic.sol`, but these two files don't need that here.


#### Call Relationships Between Code

Taking the `Create` method of the `Item` entity as an example. Here's a code snippet from the generated `ItemSystem.sol` contract:


```solidity
// ...
contract ItemSystem is System, IAppSystemErrors {
   // ...
  function itemCreate(uint32 itemId, bool requiredForCompletion, uint32 sellsFor, string memory name) public {
    _requireNamespaceOwner();
    ItemData memory itemData = Item.get(itemId); // Use MUD-generated DAL library to read data
    if (!(itemData.requiredForCompletion == false && itemData.sellsFor == uint32(0) && bytes(itemData.name).length == 0)) {
      revert ItemAlreadyExists(itemId);
    }
    ItemCreated memory itemCreated = ItemCreateLogic.verify(itemId, requiredForCompletion, sellsFor, name); 
    // Above calls `ItemCreateLogic.verify` function to verify the input; this function returns an "event" object
    itemCreated.itemId = itemId;
    emit ItemCreatedEvent(itemCreated.itemId, itemCreated.requiredForCompletion, itemCreated.sellsFor, itemCreated.name);
    ItemData memory newItemData = ItemCreateLogic.mutate(itemCreated); 
    // Calls ItemCreateLogic.mutate function to modify the entity's "state", 
    // since this is a create operation, no "old state" is passed in
    Item.set(itemId, newItemData); // Calls MUD's generated DAL library to save the modified entity state

    // You can compare the call to `ItemUpdateLogic.mutate` function in the `itemUpdate` function:
    //     ItemData memory updatedItemData = ItemUpdateLogic.mutate(itemUpdated, itemData);
    //     Item.set(itemId, updatedItemData);
    // to understand the difference between "create" and "update" operations.
  }
  // ...
}
```



### Other Object Models and Generated Code

[Content to be added]

### Key Declarations in Models and Their Impact on Generated Code

[Content to be added]

