# 项目合约代码结构与 DDDML 模型驱动开发说明

## 对本文读者的要求

* 对 MUD 框架，以及使用 MUD 框架开发的 Dapp 的结构有基本的了解。
* 对 DDD（领域驱动设计）以及 DDDML 有大致的概念。

DDDML 是我们基于 DDD 的理念创建的一门领域专用语言（DSL）。
这里有一篇关于使用 DDDML 以及相关工具进行 MUD 应用开发的入门参考文章：https://hackmd.io/GjSU_oWvTlCtMBtIA28SiA


## 项目合约代码的生成过程

> 注：dddappp 是我们创建的低代码工具。它支持使用 DDDML 模型驱动 Move Dapp 以及 EVM/MUD Dapp 的开发。
> （未来它会支持更多 Web3 基础设施/公链；事实上它还支持“传统” Web2 应用的开发。）


```ascii
                   DDDML Models (*.yaml)
                          │
                          │ dddappp tool (MUD version)
                          ▼
     ┌─────────────────────────────────────────┐
     │                                         │
     ▼                                         ▼
MUD Data Model                          MUD Systems
(mud.config.ts)                    (*System.sol / *Logic.sol)
     │                                         │
     │ mud tablegen                            │ mud worldgen
     ▼                                         ▼
Tables (DAL)                          Interfaces
(codegen/tables/*.sol)               (codegen/world/*.sol)
     │                                         │
     └─────────────────┐     ┌─────────────────┘
                       │     │
                       ▼     ▼
                   Final Contract
                      Code
```

这个图展示了从 DDDML 模型到最终合约代码的转换过程：

1. DDDML 模型（在 `dddml` 目录下的 `*.yaml` 文件）是最高层的抽象，它描述了领域模型
2. dddappp 工具（MUD 版本）将 DDDML 模型转换为：
   - MUD 数据模型（在 `mud.config.ts` 文件中）
   - MUD Systems（Solidity 合约）以及模型中定义的“方法”所对应的“业务逻辑”脚手架代码
3. MUD 工具链进一步处理：
   - tablegen 从 MUD 数据模型生成 DAL 代码
   - worldgen 从 MUD Systems 提取接口定义
4. 最终所有这些代码组合成完整的合约代码（需要开发者填充“业务逻辑”的实现代码）


## 合约项目的结构

很容易分辨哪些合约代码是工具生成的（合约在代码库的 `packages/contracts` 目录下）：

- 在生成的代码文件的头部，有 `/* Autogenerated file. Do not edit manually. */` 这样的注释。
- 从文件名上也很容易分辨：文件名以 `Logic.sol` 结尾的，或以 `ServiceSystem.sol` 结尾的，需要开发者填充业务逻辑实现。（但是这些文件也是由工具先生成了脚手架代码，其中包含了所需的函数的签名部分，开发者需要填充函数体。）
- 在 `src/utils` 目录下的文件，是开发者手动编写的一些工具库。


下面，我们使用 tree 命令输出合约项目的结构：

```
cd packages/contracts
tree .
```

然后，我们在输出的内容中加上注释，解释每个目录和文件的作用：

```txt
.
├── ...
├── script // 部署以及其他运维脚本
│   ├── ...
│   ├── PostDeploy.s.sol
│   └── ...
├── src
│   ├── codegen // 这个目录中的所有文件都是 MUD 的工具生成的
│   │   ├── index.sol
│   │   ├── tables // MUD 工具生成的 DAL（数据访问层）代码
│   │   │   ├── EnergyDrop.sol
│   │   │   ├── ...
│   │   │   └── XpTableLevelCount.sol
│   │   └── world // 这个目录中的所有文件都是 MUD 的工具生成的接口
│   │       ├── IAggregatorServiceSystem.sol
│   │       ├── ...
│   │       └── IWorld.sol
│   ├── systems // 这个目录下只有后缀名为 `Logic.sol` 以及 `ServiceSystem.sol` 的文件是包含了手动编码的
│   │   ├── EnergyDropRequestLogic.sol
│   │   ├── ExperienceTableAddLevelLogic.sol
│   │   ├── IslandClaimWhitelistAddLogic.sol
│   │   ├── ...
│   │   ├── ItemProductionCreateLogic.sol
│   │   ├── ItemUpdateLogic.sol
│   │   ├── MapAddIslandLogic.sol
│   │   ├── ...
│   │   ├── AggregatorServiceSystem.sol
│   │   ├── ShipBattleServiceSystem.sol
│   │   ├── ...
│   ├── tokens // ENERGY ERC-20 合约，项目使用的 ENERGY 代币的合约地址是可以配置的
│   │   └── Energy.sol
│   └── utils // 工具函数
│       ├── DirectRouteUtil.sol
│       ├── ExperienceTableUtil.sol
│       ├── FightToDeath.sol
│       ├── ItemIds.sol
│       ├── LootUtil.sol
│       ├── MapUtil.sol
│       ├── PlayerInventoryUpdateUtil.sol
│       ├── PlayerUtil.sol
│       ├── RosterDataInstance.sol
│       ├── RosterSailUtil.sol
│       ├── RosterUtil.sol
│       ├── RouteUtil.sol
│       ├── ShipBattleUtil.sol
│       ├── ShipIdUtil.sol
│       ├── ShipInventoryUpdateUtil.sol
│       ├── ShipUtil.sol
│       ├── SkillProcessUtil.sol
│       ├── SortedVectorUtil.sol
│       ├── SpeedUtil.sol
│       └── TsRandomUtil.sol
├── test // 单元测试
│   ├── ShipIdUtilTest.t.sol
│   └── ...

```


## DDDML 模型到合约代码的映射

> 注：下文所说的*聚合*、*聚合根*、*实体*是 DDD 中的概念。你可以花一些时间去搜索并了解 DDD 的概念，这对你理解本文会有帮助。
> 如果你实在没有时间，那么你可以先记住：*聚合根*是实体的一种。
> 而实体是大部分有技术背景的人已经比较熟悉的一个概念，通常可以理解为：一个具有唯一标识的对象。


### 典型的实体模型以及生成的代码

#### 示例：`Item`

这是聚合根 `Item` 的 DDDML 模型文件：

```yaml
aggregates:
  Item:
    metadata:
      Preprocessors: [ "CRUD_IT" ]
      #CRUD_IT_NO_UPDATE: true
      CRUD_IT_NO_DELETE: true
    id:
      name: ItemId
      type: u32
    properties:
      RequiredForCompletion:
        type: bool
      SellsFor:
        type: u32
      Name:
        type: string
        length: 100
    methods:
      Create:
        requiredPermission: __NamespaceOwner__ # "__Publisher__"
      Update:
        requiredPermission: __NamespaceOwner__ # "__Publisher__"
```

如果 CRUD（创建、读取、更新、删除）就是你所需要的“业务逻辑”，那么你甚至不用编写任何代码。就像上面的 Item 实体。
我们使用 `CRUD_IT` 预处理器来生成 Create 和 Update 方法的代码，但是禁止了 Delete 方法的生成。

- MUD 工具生成的 DAL 代码在：`src/codegen/tables/Item.sol`。
- 这个模型对应的 System 合约文件在：`src/systems/ItemSystem.sol`。每个 MUD System 是一个无状态的 Solidity 合约。
- Create 和 Update 方法对应的“业务逻辑”的实现在：
  - `src/systems/ItemCreateLogic.sol`
  - `src/systems/ItemUpdateLogic.sol`
  - 如果在模型中定义的方法不是 CRUD，那么开发者需要在 `{EntityName}{MethodName}Logic.sol` 中填充“业务逻辑”的实现代码，但是这里的两个文件并不需要。


#### 代码之间的调用关系

以 `Item` 实体的 `Create` 方法为例。这是生成的 `ItemSystem.sol` 合约的代码片段：

```solidity
// ...
contract ItemSystem is System, IAppSystemErrors {
   // ...
  function itemCreate(uint32 itemId, bool requiredForCompletion, uint32 sellsFor, string memory name) public {
    _requireNamespaceOwner(); // 检查调用者是否是命名空间的所有者
    ItemData memory itemData = Item.get(itemId); // 使用 MUD 生成的 DAL 库读取数据
    if (!(itemData.requiredForCompletion == false && itemData.sellsFor == uint32(0) && bytes(itemData.name).length == 0)) {
      revert ItemAlreadyExists(itemId);
    }
    ItemCreated memory itemCreated = ItemCreateLogic.verify(itemId, requiredForCompletion, sellsFor, name); 
    // 上面调用了 ItemCreateLogic.verify 函数，来验证函数的输入；这个函数返回一个“事件”对象
    itemCreated.itemId = itemId;
    emit ItemCreatedEvent(itemCreated.itemId, itemCreated.requiredForCompletion, itemCreated.sellsFor, itemCreated.name);
    ItemData memory newItemData = ItemCreateLogic.mutate(itemCreated); 
    // 调用 ItemCreateLogic.mutate 函数，修改实体的“状态”，因为这是一个创建操作，所以不会传入“旧状态”。
    Item.set(itemId, newItemData); // 使用 MUD 生成的 DAL 库保存修改后的实体状态

    // 可以比较一下 itemUpdate 函数对 ItemUpdateLogic.mutate 函数的调用：
    //     ItemData memory updatedItemData = ItemUpdateLogic.mutate(itemUpdated, itemData);
    //     Item.set(itemId, updatedItemData);
    // 来理解“创建”与“更新”操作之间的区别。
  }
  // ...
}
```



### 其他对象模型以及生成的代码

#### 值对象

值对象是一些简单的数据结构。不会为它们生成对应的 MUD tables。

##### 示例：`ItemIdQuantityPair`

模型文件：

```yaml
valueObjects:
  ItemIdQuantityPair:
    properties:
      ItemId:
        type: u32 # 物品的 ID
      Quantity:
        type: u32 # 物品的数量
```

在 Infinite Seas 游戏的模型中，很多地方（对象的属性、方法的参数）都需要用到“物品的 ID 和数量”这样的组合。
我们在这些地方可以直接使用 `ItemIdQuantityPair` 这个类型，这让模型的表述更加简洁明了。

对应的 Solidity 代码在 `src/Systems/ItemIdQuantityPair.sol`。

```solidity
// ...
struct ItemIdQuantityPair {
  uint32 itemId;
  uint32 quantity;
}
```


##### 示例：`SkillProcessId`

模型文件：

```yaml
valueObjects:
  SkillProcessId:
    properties:
      SkillType:
        type: SkillType
      PlayerId:
        type: u256
      SequenceNumber:
        type: u8
```

对应的 Solidity 代码在 `src/Systems/SkillProcessId.sol`。


#### 服务

服务一般来说，不应该包含过于复杂的业务逻辑，它们应该通过使用一些“胶水”代码组合调用“实体的方法”来实现功能。

##### 示例：`AggregatorService`

```yaml
services:
  AggregatorService:
    metadata:
      GlobalFunctionNamePrefix: "UniApi" # Unified API
    methods:
      StartCreation:
        parameters:
          SkillType:
            type: u8
          PlayerId:
            type: u256
          SkillProcessSequenceNumber:
            type: u8
          ItemId:
            type: u32
          BatchSize:
            type: u32
      # ...
```

我们的工具会为 Service 生成对应的 MUD System 合约。
定义这个 Service 的意图之一，是将需要花费 ENERGY 代币的函数都集中在这里，这样用户只需要批准这个合约使用 ENERGY 代币就可以了，而不需要批准多个合约。

对应的 Solidity 代码在 `src/Systems/AggregatorService.sol`。这个文件中的函数体需要开发者填充。

```solidity
contract AggregatorServiceSystem is System {
  // ...
  function uniApiStartCreation(
    uint8 skillType,
    uint256 playerId,
    uint8 skillProcessSequenceNumber,
    uint32 itemId,
    uint32 batchSize
  ) public {
    // ...
    SkillProcessDelegatecallLib.startCreation(skillType, playerId, skillProcessSequenceNumber, itemId, batchSize);
  }
}
```

### 模型中的关键声明以及对生成的代码的影响


#### 将代码拆分为 Systems

在默认情况下，dddappp 工具会为每个实体（聚合根）生成对应的 System 合约。

- 实体的方法默认会放置在文件名为 `{EntityName}System.sol` 的合约中。
- 实体的 `IsOnlyOpenToFriends` 属性为 `true` 的方法默认会放置在文件名为 `{EntityName}FriendSystem.sol` 的合约中。

我们还可以通过在模型中使用 `MudSystemName` 属性来控制为某个方法生成的代码放置在哪个 System 合约中。

这是 `Roster` 聚合根的 DDDML 模型文件中的代码片段：

```yaml
aggregates:
  Roster:
    # ...
    methods:
      Create:
        metadata:
          IsOnlyOpenToFriends: true
          # 这个方法默认会生成在 `RosterFriendSystem` 合约中
        isCreationCommand: true
        parameters:
          # ...

      SetSail:
        metadata:
          IsOnlyOpenToFriends: true
          MudSystemName: RosterSailingSystem
          DisableFlatteningForParameters: ["UpdateLocationParams"]
        parameters:
          # ...

      CleanUpBattleDestroyedShips:
        metadata:
          IsOnlyOpenToFriends: true
          MudSystemName: RosterCleaningSystem
        parameters:
          # ...


      TransferShip:
        # IsOnlyOpenToFriends 默认是 false。
        # 这个方法默认会生成在 `RosterSystem` 合约中
        parameters:
          ShipId:
            type: u256
          # ...
        event:
          name: RosterShipTransferred
          # ...
```

这里需要说明的是：放置在同一个系统中的方法，它们的 `IsOnlyOpenToFriends` 属性必须相同。

当一个系统（中的所有方法）的 `IsOnlyOpenToFriends` 属性为 `true` 时，在 MUD 配置文件 `mud.config.ts` 中，它的 `openAccess` 属性会被设置为 `false`。这意味着这个系统中的函数默认是不能从外部进行调用的。
（正如之前所说，这个 MUD 配置文件是 dddappp 工具根据模型文件生成的。）


```typescript
export default defineWorld({
  namespace: "app",
  // ...
  systems: {
    // ...
    RosterFriendSystem: {
      openAccess: false,
    },
    RosterSailingSystem: {
      openAccess: false,
    },
    RosterCleaningSystem: {
      openAccess: false,
    },
    // ...
  },
  // ...
});
```

##### 合约大小限制

将“公用”的代码放置在 `utils` 目录的库代码中，虽然可以实现代码的复用，但是并不能有效减少编译出来的合约的大小。

Ethereum 合约的大小是有限制的。一般的做法是使用公共库来绕过这个限制。
不过使用“公共库”的方式，这些“合约”脱离了 MUD 框架的管理，也就无法使用 MUD 工具链可以提供的各种便利，比如编译和部署合约时工具可以提供的便利。
而且在其中编写业务逻辑的时候，公共库中的代码无法直接使用 `_msgSender()` 和 `_msgValue()` 这些 MUD 框架提供的函数，当然我们可以用从函数参数传入对应的值的方式绕过。不过这也会使得这些代码和其他 System 中实现业务逻辑的代码在风格上不一致，也不够简洁和直观。

> 注：MUD System 本质上是个无状态的合约，在这一点上它和“公共库”很类似。
> 对 MUD System 合约的调用，一般情况下是通过 World 合约代理的。MUD 应用的状态是置于 MUD 框架的管理之下的。

我们采用的方式，正如上面所示，是在模型中将需要“剥离”到“公共库”中的方法声明为 `IsOnlyOpenToFriends: true`。这会使得这些方法（对应的函数）所在的 MUD System 的 `openAccess` 属性会被设置为 `false`。其他合约可以通过 delegatecall 的方式调用这些合约/函数。

为了方便其他合约调用这些类似“公共库”的 MUD System 合约，我们的 DDDML 工具为它们生成了对应的“包装”库（`{EntityName}DelegatecallLib.sol`）。

比如，这是 `RosterDelegatecallLib` 库的代码片段：

```solidity
library RosterDelegatecallLib {
  // ...
  function setSail(uint256 playerId, uint32 sequenceNumber, uint32 targetCoordinatesX, uint32 targetCoordinatesY, uint64 sailDuration, UpdateLocationParams memory updateLocationParams, Coordinates[] memory intermediatePoints) internal {
    ResourceId rosterSailingSystemId = WorldResourceIdLib.encode({
      typeId: RESOURCE_SYSTEM,
      namespace: "app",
      name: "RosterSailingSys" // NOTE: Only the first 16 characters are used. Original: "RosterSailingSystem"
    });

    (address rosterSailingSystemAddress, ) = Systems.get(rosterSailingSystemId);
    (bool success, bytes memory returnData) = WorldContextProviderLib.delegatecallWithContext(
      WorldContextConsumerLib._msgSender(),
      0,
      rosterSailingSystemAddress,
      abi.encodeWithSignature(
        "rosterSetSail(uint256,uint32,uint32,uint32,uint64,((uint32,uint32),uint16,uint64),(uint32,uint32)[])",
        playerId, sequenceNumber, targetCoordinatesX, targetCoordinatesY, sailDuration, updateLocationParams, intermediatePoints
      )
    );
    if (!success) revertWithBytes(returnData);

  }
  // ...
}
```

在上面的示例代码中，我们使用了 `WorldContextProviderLib.delegatecallWithContext` 这个 MUD 框架提供的库函数。
它在 Solidity 原生的 `delegatecall` 函数的基础上，增加了对 MUD 框架上下文变量的传递。
这使得在被调用的系统合约中可以使用 `_msgSender()` 和 `_msgValue()` 这些 MUD 框架提供的函数。



