# 项目合约代码结构与 DDDML 模型驱动开发说明

## 对本文读者的要求

* 对 MUD 框架，以及使用 MUD 框架开发的 Dapp 的结构有基本的了解。
* 对 DDDML 有大致的概念。

这里有一篇关于使用 DDDML 以及相关工具进行 MUD 应用开发的入门参考文章：https://hackmd.io/GjSU_oWvTlCtMBtIA28SiA


## 项目合约代码的生成过程

> 注：dddappp 是我们创建的低代码工具。它支持使用 DDDML 模型驱动 Move Dapp 以及 EVM/MUD Dapp 的开发。（事实上还支持“传统应用”的开发。）


```ascii
                   DDDML Models (*.yaml)
                          │
                          │ dddappp tool (MUD version)
                          ▼
     ┌─────────────────────────────────────────┐
     │                                         │
     ▼                                         ▼
MUD Data Model                          MUD Systems
(mud.config.ts)                    (*System.sol / *Logic.sol)
     │                                         │
     │ mud tablegen                            │ mud worldgen
     ▼                                         ▼
Tables (DAL)                          Interfaces
(codegen/tables/*.sol)               (codegen/world/*.sol)
     │                                         │
     └─────────────────┐     ┌─────────────────┘
                       │     │
                       ▼     ▼
                   Final Contract
                      Code
```

这个图展示了从 DDDML 模型到最终合约代码的转换过程：

1. DDDML 模型（在 `dddml` 目录下的 `*.yaml` 文件）是最高层的抽象，它描述了领域模型
2. dddappp 工具（MUD 版本）将 DDDML 模型转换为：
   - MUD 数据模型（在 `mud.config.ts` 文件中）
   - MUD Systems（Solidity 合约）以及模型中定义的“方法”所对应的“业务逻辑”脚手架代码
3. MUD 工具链进一步处理：
   - tablegen 从 MUD 数据模型生成 DAL 代码
   - worldgen 从 MUD Systems 提取接口定义
4. 最终所有这些代码组合成完整的合约代码（需要开发者填充“业务逻辑”的实现代码）

很容易分辨哪些合约代码是工具生成的（合约在代码库的 `packages/contracts` 目录下）：

- 在生成的代码文件的头部，有 `/* Autogenerated file. Do not edit manually. */` 这样的注释。
- 从文件名上也很容易分辨：文件名以 `Logic.sol` 结尾的，或以 `ServiceSystem.sol` 结尾的，需要开发者填充业务逻辑实现。（但是这些文件也是由工具先生成了脚手架代码，其中包含了所需的函数的签名部分，开发者需要填充函数体。）
- 在 `src/utils` 目录下的文件，是开发者手动编写的一些工具库。


## 合约项目的结构

下面，我们使用 tree 命令输出合约项目的结构：

```
cd packages/contracts
tree .
```

然后，我们在输出的内容中加上注释，解释每个目录和文件的作用：

```txt
.
├── ...
├── script // 部署以及其他运维脚本
│   ├── ...
│   ├── PostDeploy.s.sol
│   └── ...
├── src
│   ├── codegen // 这个目录中的所有文件都是 MUD 的工具生成的
│   │   ├── index.sol
│   │   ├── tables // MUD 工具生成的 DAL（数据访问层）代码
│   │   │   ├── EnergyDrop.sol
│   │   │   ├── ...
│   │   │   └── XpTableLevelCount.sol
│   │   └── world // 这个目录中的所有文件都是 MUD 的工具生成的接口
│   │       ├── IAggregatorServiceSystem.sol
│   │       ├── ...
│   │       └── IWorld.sol
│   ├── systems // 这个目录下只有后缀名为 `Logic.sol` 以及 `ServiceSystem.sol` 的文件是包含了手动编码的
│   │   ├── EnergyDropRequestLogic.sol
│   │   ├── ExperienceTableAddLevelLogic.sol
│   │   ├── IslandClaimWhitelistAddLogic.sol
│   │   ├── ...
│   │   ├── ItemProductionCreateLogic.sol
│   │   ├── ItemUpdateLogic.sol
│   │   ├── MapAddIslandLogic.sol
│   │   ├── ...
│   │   ├── AggregatorServiceSystem.sol
│   │   ├── ShipBattleServiceSystem.sol
│   │   ├── ...
│   ├── tokens // ENERGY ERC-20 合约，项目使用的 ENERGY 代币的合约地址是可以配置的
│   │   └── Energy.sol
│   └── utils // 工具函数
│       ├── DirectRouteUtil.sol
│       ├── ExperienceTableUtil.sol
│       ├── FightToDeath.sol
│       ├── ItemIds.sol
│       ├── LootUtil.sol
│       ├── MapUtil.sol
│       ├── PlayerInventoryUpdateUtil.sol
│       ├── PlayerUtil.sol
│       ├── RosterDataInstance.sol
│       ├── RosterSailUtil.sol
│       ├── RosterUtil.sol
│       ├── RouteUtil.sol
│       ├── ShipBattleUtil.sol
│       ├── ShipIdUtil.sol
│       ├── ShipInventoryUpdateUtil.sol
│       ├── ShipUtil.sol
│       ├── SkillProcessUtil.sol
│       ├── SortedVectorUtil.sol
│       ├── SpeedUtil.sol
│       └── TsRandomUtil.sol
├── test // 单元测试
│   ├── ShipIdUtilTest.t.sol
│   └── ...

```


## DDDML 模型到合约代码的映射

### 典型的实体模型以及生成的代码

#### 示例：`Item`

模型文件：

```yaml
aggregates:
  Item:
    metadata:
      Preprocessors: [ "CRUD_IT" ]
      #CRUD_IT_NO_UPDATE: true
      CRUD_IT_NO_DELETE: true
    id:
      name: ItemId
      type: u32
    properties:
      RequiredForCompletion:
        type: bool
      SellsFor:
        type: u32
      Name:
        type: string
        length: 100
    methods:
      Create:
        requiredPermission: __NamespaceOwner__ # "__Publisher__"
      Update:
        requiredPermission: __NamespaceOwner__ # "__Publisher__"
```

如果 CRUD（创建、读取、更新、删除）就是你所需要的“业务逻辑”，那么你甚至不用编写任何代码。就像上面的 Item 实体。
我们使用 `CRUD_IT` 预处理器来生成 Create 和 Update 方法的代码，但是禁止了 Delete 方法的生成。

- MUD 工具生成的 DAL 代码在：`src/codegen/tables/Item.sol`。
- 这个模型对应的 System 合约文件在：`src/systems/ItemSystem.sol`。
- Create 和 Update 方法对应的“业务逻辑”的实现在：
  - `src/systems/ItemCreateLogic.sol`
  - `src/systems/ItemUpdateLogic.sol`
  - 如果在模型中定义的方法不是 CRUD，那么开发者需要在 `{EntityName}{MethodName}Logic.sol` 中填充“业务逻辑”的实现代码，但是这里的两个文件并不需要。

#### 代码之间的调用关系

以 `Item` 实体的 `Create` 方法为例。这是生成的 `ItemSystem.sol` 合约的代码片段：

```solidity
// ...
contract ItemSystem is System, IAppSystemErrors {
   // ...
  function itemCreate(uint32 itemId, bool requiredForCompletion, uint32 sellsFor, string memory name) public {
    _requireNamespaceOwner();
    ItemData memory itemData = Item.get(itemId); // 使用 MUD 生成的 DAL 库读取数据
    if (!(itemData.requiredForCompletion == false && itemData.sellsFor == uint32(0) && bytes(itemData.name).length == 0)) {
      revert ItemAlreadyExists(itemId);
    }
    ItemCreated memory itemCreated = ItemCreateLogic.verify(itemId, requiredForCompletion, sellsFor, name); 
    // 上面调用了 ItemCreateLogic.verify 函数，来验证函数的输入；这个函数返回一个“事件”对象
    itemCreated.itemId = itemId;
    emit ItemCreatedEvent(itemCreated.itemId, itemCreated.requiredForCompletion, itemCreated.sellsFor, itemCreated.name);
    ItemData memory newItemData = ItemCreateLogic.mutate(itemCreated); 
    // 调用 ItemCreateLogic.mutate 函数，修改实体的“状态”，因为这是一个创建操作，所以不会传入“旧状态”。
    Item.set(itemId, newItemData); // 使用 MUD 生成的 DAL 库保存修改后的实体状态

    // 可以比较一下 itemUpdate 函数对 ItemUpdateLogic.mutate 函数的调用：
    //     ItemData memory updatedItemData = ItemUpdateLogic.mutate(itemUpdated, itemData);
    //     Item.set(itemId, updatedItemData);
    // 来理解“创建”与“更新”操作之间的区别。
  }
  // ...
}
```



### 其他对象模型以及生成的代码


[待补充具体内容]


### 模型中的关键声明以及对生成的代码的影响


[待补充具体内容]

